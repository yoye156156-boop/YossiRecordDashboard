import fetch from 'node-fetch';
import puppeteer from "puppeteer";
import { marked } from "marked";
import { installNotes } from "./notesRoutes.mjs";
import express from 'express';
import multer from 'multer';
import cors from 'cors';
import morgan from 'morgan';
import path from 'path';
import { fileURLToPath } from 'url';
import fs from 'fs';
import fsp from 'fs/promises';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
app.use(cors());
app.use(express.json({ limit: '10mb' }));
app.use(morgan('dev'));

// --- ENV & Dirs ---
const PORT = process.env.PORT || 3001;
const RECORDINGS_DIR = process.env.RECORDINGS_DIR || path.join(__dirname, 'recordings');
const NOTES_DIR = path.join(__dirname, 'notes');

for (const dir of [RECORDINGS_DIR, NOTES_DIR]) {
  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
}

// --- Multer storage ---
const storage = multer.diskStorage({
  destination: (_req, _file, cb) => cb(null, RECORDINGS_DIR),
  filename: (_req, file, cb) => {
    const ext = path.extname(file.originalname) || '.webm';
    const base = path
      .basename(file.originalname, ext)
      .replace(/[^\p{L}\p{N}_\-. ]/gu, '_');
    cb(null, `${base}${ext}`);
  }
});
const upload = multer({ storage });

// --- Helpers ---
function toItemStats(p) {
  const st = fs.statSync(p);
  const ext = path.extname(p);
  const mime =
    ext === '.webm' ? 'video/webm' :
    ext === '.wav'  ? 'audio/wav'  :
                      'application/octet-stream';
  return {
    name: path.basename(p),
    sizeKB: Math.round(st.size / 1024),
    ext,
    mime,
    mtime: st.mtimeMs,
    mtimeISO: new Date(st.mtimeMs).toISOString()
  };
}

async function safeWriteJSON(absPath, obj) {
  await fsp.writeFile(absPath, JSON.stringify(obj, null, 2), 'utf8');
}

function baseOf(name) {
  const ext = path.extname(name);
  return path.basename(name, ext);
}

// --- Routes ---
app.get('/health', (_req, res) => {
  res.json({ ok: true, ts: Date.now() });
});

// List recordings
app.get('/api/recordings', async (_req, res) => {
  try {
    const files = await fsp.readdir(RECORDINGS_DIR);
    const items = files
      .filter((f) => !f.startsWith('.'))
      .map((f) => path.join(RECORDINGS_DIR, f))
      .filter((p) => fs.statSync(p).isFile())
      .map(toItemStats)
      .sort((a, b) => b.mtime - a.mtime);
    res.json({ ok: true, items });
  } catch (e) {
    res.status(500).json({ ok: false, error: e.message });
  }
});

// Upload recording
app.post('/api/upload', upload.single('file'), (req, res) => {
if (req.file && req.file.filename) {
  const name = req.file.filename;
  console.log(`ğŸ§ ×§×•×‘×¥ ×”×•×¢×œ×”: ${name} â€” ××ª×—×™×œ ×™×¦×™×¨×ª ×›×ª×‘ ××—×¨×™...`);

  fetch(`http://127.0.0.1:${PORT}/api/transcribe`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ name })
  })
  .then(r => r.json())
  .then(js => {
    if (js.ok) {
      console.log(`ğŸ§  × ×•×¦×¨ ×›×ª×‘ ××—×¨×™ ××•×˜×•××˜×™ ×¢×‘×•×¨ ${name}`);
    } else {
      console.warn(`âš ï¸ ×©×’×™××” ×‘×™×¦×™×¨×ª ×›×ª×‘ ××—×¨×™:`, js.error);
    }
  })
  .catch(err => console.error(`âŒ ×©×’×™××” ×‘×¤× ×™×™×” ×œ-/api/transcribe:`, err));
}
  res.json({ ok: true, name: req.file?.filename });
});

// Rename recording
app.put('/api/recordings/:name', async (req, res) => {
  try {
    const oldName = req.params.name;
    const { newName } = req.body || {};
    if (!newName) return res.status(400).json({ ok: false, error: 'newName required' });

    const oldPath = path.join(RECORDINGS_DIR, oldName);
    if (!fs.existsSync(oldPath)) return res.status(404).json({ ok: false, error: 'not found' });

    const currentExt = path.extname(oldName);
    const reqExt = path.extname(newName);
    const finalName = reqExt ? newName : newName + currentExt;
    const safe = finalName.replace(/[^\p{L}\p{N}_\-. ]/gu, '_');

    const newPath = path.join(RECORDINGS_DIR, safe);
    await fsp.rename(oldPath, newPath);

    // move side files (markers + notes) if exist
    const oldBase = baseOf(oldName);
    const newBase = baseOf(safe);

    const maybeMove = async (dir, ext) => {
      const from = path.join(dir, `${oldBase}${ext}`);
      if (fs.existsSync(from)) {
        await fsp.rename(from, path.join(dir, `${newBase}${ext}`));
      }
    };
    await maybeMove(RECORDINGS_DIR, '.json'); // markers JSON
    await maybeMove(NOTES_DIR, '.json');      // summary JSON
    await maybeMove(NOTES_DIR, '.md');        // summary MD
    if (req.file && req.file.filename) {
  const name = req.file.filename;
  console.log(`ğŸ§ ×§×•×‘×¥ ×”×•×¢×œ×”: ${name} â€” ××ª×—×™×œ ×™×¦×™×¨×ª ×›×ª×‘ ××—×¨×™...`);

  // ×§×¨×™××” ×¤× ×™××™×ª ×œ-/api/transcribe
  fetch(`http://127.0.0.1:${PORT}/api/transcribe`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ name })
  })
  .then(r => r.json())
  .then(js => {
    if (js.ok) {
      console.log(`ğŸ§  × ×•×¦×¨ ×›×ª×‘ ××—×¨×™ ××•×˜×•××˜×™ ×¢×‘×•×¨ ${name}`);
    } else {
      console.warn(`âš ï¸ ×©×’×™××” ×‘×™×¦×™×¨×ª ×›×ª×‘ ××—×¨×™:`, js.error);
    }
  })
  .catch(err => console.error(`âŒ ×©×’×™××” ×‘×¤× ×™×™×” ×œ-/api/transcribe:`, err));
}
    res.json({ ok: true, name: safe });
  } catch (e) {
    res.status(500).json({ ok: false, error: e.message });
  }
});

// Delete recording (+ markers)
app.delete('/api/recordings/:name', async (req, res) => {
  try {
    const name = req.params.name;
    const p = path.join(RECORDINGS_DIR, name);
    if (!fs.existsSync(p)) return res.status(404).json({ ok: false, error: 'not found' });
    await fsp.unlink(p);
    const base = baseOf(name);
    for (const ext of ['.json']) {
      const side = path.join(RECORDINGS_DIR, `${base}${ext}`);
      if (fs.existsSync(side)) await fsp.unlink(side);
    }
    res.json({ ok: true });
  } catch (e) {
    res.status(500).json({ ok: false, error: e.message });
  }
});

// Stream recording
app.get('/recordings/:name', async (req, res) => {
  const p = path.join(RECORDINGS_DIR, req.params.name);
  if (!fs.existsSync(p)) return res.status(404).end();
  const stat = await fsp.stat(p);
  res.setHeader('Cache-Control', 'no-store');
  const range = req.headers.range;
  if (!range) {
    res.writeHead(200, { 'Content-Length': stat.size });
    fs.createReadStream(p).pipe(res);
    return;
  }
  const [startStr, endStr] = range.replace(/bytes=/, '').split('-');
  const start = parseInt(startStr, 10);
  const end = endStr ? parseInt(endStr, 10) : stat.size - 1;
  const chunksize = end - start + 1;
  const file = fs.createReadStream(p, { start, end });
  res.writeHead(206, {
    'Content-Range': `bytes ${start}-${end}/${stat.size}`,
    'Accept-Ranges': 'bytes',
    'Content-Length': chunksize
  });
  file.pipe(res);
});

// Save markers
app.post('/api/recordings/:name/markers', async (req, res) => {
  try {
    const { name } = req.params;
    const base = baseOf(name);
    const recPath = path.join(RECORDINGS_DIR, name);
    if (!fs.existsSync(recPath)) return res.status(404).json({ ok: false, error: 'recording not found' });
    const markers = Array.isArray(req.body?.markers) ? req.body.markers : [];
    const payload = { recording: name, markers, savedAt: new Date().toISOString() };
    await safeWriteJSON(path.join(RECORDINGS_DIR, `${base}.json`), payload);
    res.json({ ok: true, markers: payload });
  } catch (e) {
if (req.file && req.file.filename) {
  const name = req.file.filename;
  console.log(`ğŸ§ ×§×•×‘×¥ ×”×•×¢×œ×”: ${name} â€” ××ª×—×™×œ ×™×¦×™×¨×ª ×›×ª×‘ ××—×¨×™...`);

  // ×§×¨×™××” ×¤× ×™××™×ª ×œ-/api/transcribe
  fetch(`http://127.0.0.1:${PORT}/api/transcribe`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ name })
  })
  .then(r => r.json())
  .then(js => {
    if (js.ok) {
      console.log(`ğŸ§  × ×•×¦×¨ ×›×ª×‘ ××—×¨×™ ××•×˜×•××˜×™ ×¢×‘×•×¨ ${name}`);
    } else {
      console.warn(`âš ï¸ ×©×’×™××” ×‘×™×¦×™×¨×ª ×›×ª×‘ ××—×¨×™:`, js.error);
    }
  })
  .catch(err => console.error(`âŒ ×©×’×™××” ×‘×¤× ×™×™×” ×œ-/api/transcribe:`, err));
}
    res.status(500).json({ ok: false, error: e.message });
  }
});

// Summarize (mock)
app.post('/api/summarize', async (req, res) => {
  try {
    const { name } = req.body || {};
    if (!name) return res.status(400).json({ ok: false, error: 'name required' });
    const recPath = path.join(RECORDINGS_DIR, name);
    if (!fs.existsSync(recPath)) return res.status(404).json({ ok: false, error: 'recording not found' });

    const base = baseOf(name);
    const markersPath = path.join(RECORDINGS_DIR, `${base}.json`);
    let markers = [];
    if (fs.existsSync(markersPath)) {
      try {
        const js = JSON.parse(await fsp.readFile(markersPath, 'utf8'));
        markers = js.markers || [];
      } catch {}
    }

    const now = new Date().toISOString();
    const summary = {
      recording: name,
      createdAt: now,
      mood: '××ª×•×—/×” ×‘×ª×—×™×œ×ª ×”×¤×’×™×©×”, ×¨×’×•×¢/×” ×‘×¡×•×¤×”',
      automaticThoughts: [
        '×× ×× ×™ ×œ× ××¦×œ×™×— â€“ ×–×” ××•××¨ ×©×× ×™ ×›×™×©×œ×•×Ÿ',
        '×”× ×™×©×¤×˜×• ××•×ª×™ ×× ××ª×‘×œ×‘×œ'
      ],
      cognitiveDistortions: ['×”×›×œ ××• ×›×œ×•×', '×§×¨×™××ª ××—×©×‘×•×ª', '×”×›×œ×œ×” ××•×’×–××ª'],
      keyMoments: markers.slice(0, 5),
      challenges: ['×”×™×× ×¢×•×ª ××©×™×—×•×ª ×§×©×•×ª', '×“×—×™×™× ×•×ª'],
      homework: [
        '×ª×¨×’×•×œ × ×©×™××•×ª 4-7-8 ×¤×¢××™×™× ×‘×™×•×',
        '× ×™×¡×•×™ ×”×ª× ×”×’×•×ª×™: ×©×™×—×” ×§×¦×¨×” ×™×–×•××” ×¢× ×¢××™×ª'
      ],
      followUps: ['×‘×“×™×§×ª ×ª×“×™×¨×•×ª ××—×©×‘×•×ª ×©×œ×™×œ×™×•×ª ×‘×©×‘×•×¢ ×”×‘×']
    };

    const md =
`# ×›×ª×‘ ××—×¨×™ â€“ ${base}

**×ª××¨×™×š:** ${now}

**××¦×‘ ×¨×’×©×™:** ${summary.mood}

**××—×©×‘×•×ª ××•×˜×•××˜×™×•×ª:**
- ${summary.automaticThoughts.join('\n- ')}

**×¢×™×•×•×ª×™× ×§×•×’× ×™×˜×™×‘×™×™×:**
- ${summary.cognitiveDistortions.join('\n- ')}

**×¨×’×¢×™ ××¤×ª×—:**
${summary.keyMoments.map(m => `- ${m.time} â€“ ${m.tag || '×¡××Ÿ'}`).join('\n') || '- (×˜×¨× ×¡×•×× ×•)'}

**××ª×’×¨×™×:**
- ${summary.challenges.join('\n- ')}

**××©×™××•×ª ×‘×™×ª:**
- ${summary.homework.join('\n- ')}

**× ×§×•×“×•×ª ×œ××¢×§×‘:**
- ${summary.followUps.join('\n- ')}
`;

    await safeWriteJSON(path.join(NOTES_DIR, `${base}.json`), summary);
    await fsp.writeFile(path.join(NOTES_DIR, `${base}.md`), md, 'utf8');

    res.json({ ok: true, summary, markdownFile: `${base}.md` });
  } catch (e) {
    res.status(500).json({ ok: false, error: e.message });
  }
});

// Fetch summary JSON
app.get('/api/notes/:base', async (req, res) => {
  try {
    const p = path.join(NOTES_DIR, `${req.params.base}.json`);
    if (!fs.existsSync(p)) return res.status(404).json({ ok: false, error: 'not found' });
    const json = JSON.parse(await fsp.readFile(p, 'utf8'));
    res.json({ ok: true, summary: json });
  } catch (e) {
    res.status(500).json({ ok: false, error: e.message });
  }
});

// Download Markdown
app.get('/notes/:file', (req, res) => {
  const p = path.join(NOTES_DIR, req.params.file);
  if (!fs.existsSync(p)) return res.status(404).end();
  res.setHeader('Content-Type', 'text/markdown; charset=utf-8');
  res.setHeader('Content-Disposition', `attachment; filename="${req.params.file}"`);
  fs.createReadStream(p).pipe(res);
});
// ------------------- CBT Notes (dummy placeholders) -------------------


// ×”×—×–×¨×ª ×¡×™×›×•× ×§×™×™×
app.get('/api/notes/:base', async (req, res) => {
  const base = decodeURIComponent(req.params.base);
  const notePath = path.join(NOTES_DIR, `${base}.md`);
  if (!fs.existsSync(notePath)) return res.status(404).json({ ok: false, msg: 'Note not found' });
  const content = await fs.promises.readFile(notePath, 'utf8');
  res.json({ ok: true, text: content });
});

// ×™×¦×™×¨×ª ×¡×™×›×•× ×—×“×© ××“×•××” (×œ×‘×“×™×§×”)
app.post('/api/summarize', async (req, res) => {
  const { name } = req.body;
  const base = name.replace(/\.[^/.]+$/, '');
  const fakeSummary = `
**××¦×‘ ×¨×’×©×™:** ×©×™×¤×•×¨ ××ª×•×Ÿ ×œ×¢×•××ª ×”×¤×’×™×©×” ×”×§×•×“××ª  
**××—×©×‘×•×ª ××•×˜×•××˜×™×•×ª:** ×¤×—×“ ××˜×¢×•×™×•×ª, ×¦×•×¨×š ×‘×©×œ×™×˜×”  
**×¢×™×•×•×ª×™× ×§×•×’× ×™×˜×™×‘×™×™×:** ×”×›×œ ××• ×›×œ×•×, × ×™×‘×•×™ ×¢×ª×™×“  
**××˜×¨×•×ª:** ××™××•×Ÿ × ×©×™××•×ª, ×©×™×—×” ×¤×ª×•×—×” ×¢× ×‘×Ÿ ×”×–×•×’
  `;
  const notePath = path.join(NOTES_DIR, `${base}.md`);
  await fs.promises.writeFile(notePath, fakeSummary, 'utf8');
  res.json({ ok: true, text: fakeSummary });
});

// ×”×•×¨×“×ª ×§×•×‘×¥ Markdown
app.get('/notes/:file', (req, res) => {
  const file = decodeURIComponent(req.params.file);
  const full = path.join(NOTES_DIR, file);
  if (!fs.existsSync(full)) return res.status(404).send('not found');
  res.download(full);
});

  await installNotes(app, RECORDINGS_DIR);

app.listen(PORT, () => {
  console.log(`API on http://0.0.0.0:${PORT}`);
});

// ---------- CBT Notes (mock) ----------


// × ×•×•×“× ×©×™×© JSON parser (×¢×‘×•×¨ POST /api/summarize)
app.use?.(express.json({ limit: '2mb' }));

// ×”×—×–×¨×ª ×¡×™×›×•× ×§×™×™× ×›-JSON (×”-UI ×§×•×¨× ×œ×–×”)
app.get('/api/notes/:base', async (req, res) => {
  try {
    const base = decodeURIComponent(req.params.base);
    const p = path.join(NOTES_DIR, `${base}.md`);
    if (!fs.existsSync(p)) return res.status(404).json({ ok: false, error: 'not found' });
    const text = await fsp.readFile(p, 'utf8');
    res.json({ ok: true, text });
  } catch (e) {
    res.status(500).json({ ok: false, error: e.message });
  }
});

// ×™×¦×™×¨×ª ×¡×™×›×•× ×“××™×•× ×™ (×œ×—×™×¦×” ×¢×œ "×¦×•×¨ ×¡×™×›×•×")
app.post('/api/summarize', async (req, res) => {
  try {
    const { name } = req.body || {};
    if (!name) return res.status(400).json({ ok: false, error: 'missing name' });
    const base = name.replace(/\.[^.]+$/, '');
    const md = [
      '**××¦×‘ ×¨×’×©×™:** ×©×™×¤×•×¨ ××ª×•×Ÿ, ×™×¨×™×“×” ×‘×œ×—×¥ ×”×›×œ×œ×™',
      '**××—×©×‘×•×ª ××•×˜×•××˜×™×•×ª:** ×¤×—×“ ××˜×¢×•×™×•×ª; ×¦×•×¨×š ×‘×©×œ×™×˜×”',
      '**×¢×™×•×•×ª×™× ×§×•×’× ×™×˜×™×‘×™×™×:** ×”×›×œ ××• ×›×œ×•×; ×§×¨×™××ª ××—×©×‘×•×ª',
      '**××©×™××•×ª ×‘×™×ª:** ×ª×¨×’×•×œ × ×©×™××•×ª 4-7-8 ×¤×¢××™×™× ×‘×™×•×; ×©×™×—×” ×§×¦×¨×” ×™×–×•××” ×¢× ×¢××™×ª',
    ].join('\n');
    const p = path.join(NOTES_DIR, `${base}.md`);
    await fsp.writeFile(p, md, 'utf8');
    res.json({ ok: true, text: md });
  } catch (e) {
    res.status(500).json({ ok: false, error: e.message });
  }
});

// ×”×•×¨×“×ª ×”-Markdown ×›×§×•×‘×¥
app.get('/notes/:file', (req, res) => {
  const file = decodeURIComponent(req.params.file);
  const p = path.join(NOTES_DIR, file);
  if (!fs.existsSync(p)) return res.status(404).send('not found');
  res.setHeader('Content-Type', 'text/markdown; charset=utf-8');
  res.setHeader('Content-Disposition', `attachment; filename="${file}"`);
  fs.createReadStream(p).pipe(res);
});

// ===== Ensure NOTES dir, JSON + Markdown IO =====

// helper: JSON -> Markdown
function summaryToMarkdown(s) {
  const lines = [];
  lines.push(`**××¦×‘ ×¨×’×©×™:** ${s.mood || ''}`);
  if (Array.isArray(s.automaticThoughts) && s.automaticThoughts.length) {
    lines.push(`**××—×©×‘×•×ª ××•×˜×•××˜×™×•×ª:**`);
    for (const t of s.automaticThoughts) lines.push(`- ${t}`);
  }
  if (Array.isArray(s.cognitiveDistortions) && s.cognitiveDistortions.length) {
    lines.push(`**×¢×™×•×•×ª×™× ×§×•×’× ×™×˜×™×‘×™×™×:**`);
    for (const t of s.cognitiveDistortions) lines.push(`- ${t}`);
  }
  if (Array.isArray(s.homework) && s.homework.length) {
    lines.push(`**××©×™××•×ª ×‘×™×ª:**`);
    for (const t of s.homework) lines.push(`- ${t}`);
  }
  if (Array.isArray(s.keyMoments) && s.keyMoments.length) {
    lines.push(`**×¨×’×¢×™ ××¤×ª×—:**`);
    for (const m of s.keyMoments) lines.push(`- ${m.time} â€” ${m.tag || ''}`);
  }
  return lines.join('\n');
}

// GET summary JSON
app.get('/api/notes/:base', async (req, res) => {
  try {
    const base = path.basename(req.params.base);
    const jsPath = path.join(NOTES_DIR, `${base}.json`);
    if (!fs.existsSync(jsPath)) return res.status(404).json({ ok: false, error: 'not found' });
    const summary = JSON.parse(await fsp.readFile(jsPath, 'utf8'));
    res.json({ ok: true, summary });
  } catch (e) {
    res.status(500).json({ ok: false, error: e.message });
  }
});

// POST summarize â€” ×©×•××¨ ×’× JSON ×•×’× MD
app.post('/api/summarize', async (req, res) => {
  try {
    const { name } = req.body || {};
    if (!name) return res.status(400).json({ ok: false, error: 'missing name' });
    const base = path.basename(name).replace(/\.[^.]+$/, '');

    // ×“×•×’××”/××•×§: ×‘× ×” ××•×‘×™×™×§×˜ ×¡×™×›×•×
    const summary = {
      recording: name,
      createdAt: new Date().toISOString(),
      mood: '××ª×•×—/×” ×‘×ª×—×™×œ×ª ×”×¤×’×™×©×”, ×¨×’×•×¢/×” ×‘×¡×•×¤×”',
      automaticThoughts: [
        '×× ×× ×™ ×œ× ××¦×œ×™×— â€“ ×–×” ××•××¨ ×©×× ×™ ×›×™×©×œ×•×Ÿ',
        '×”× ×™×©×¤×˜×• ××•×ª×™ ×× ××ª×‘×œ×‘×œ'
      ],
      cognitiveDistortions: ['×”×›×œ ××• ×›×œ×•×', '×§×¨×™××ª ××—×©×‘×•×ª'],
      homework: ['×ª×¨×’×•×œ × ×©×™××•×ª 4-7-8 ×¤×¢××™×™× ×‘×™×•×', '×©×™×—×” ×™×–×•××” ×§×¦×¨×” ×¢× ×¢××™×ª'],
      keyMoments: []
    };

    // ×›×ª×™×‘×” ×œÖ¾JSON
    const jsPath = path.join(NOTES_DIR, `${base}.json`);
    await fsp.writeFile(jsPath, JSON.stringify(summary, null, 2), 'utf8');

    // ×™×¦×™×¨×ª Markdown ×•×©××™×¨×”
    const md = summaryToMarkdown(summary);
    const mdPath = path.join(NOTES_DIR, `${base}.md`);
    await fsp.writeFile(mdPath, md, 'utf8');

    res.json({ ok: true, summary });
  } catch (e) {
    res.status(500).json({ ok: false, error: e.message });
  }
});

// ×”×•×¨×“×ª ×”-Markdown
app.get('/notes/:file', (req, res) => {
  const file = path.basename(req.params.file);
  const p = path.join(NOTES_DIR, file);
  if (!fs.existsSync(p)) return res.status(404).send('not found');
  res.setHeader('Content-Type', 'text/markdown; charset=utf-8');
  res.setHeader('Content-Disposition', `attachment; filename="${file}"`);
  fs.createReadStream(p).pipe(res);
});

// === /api/transcribe ===
// ××“××” ×ª××œ×•×œ ×•× ×™×ª×•×— ×¨××©×•× ×™
app.post('/api/transcribe', async (req, res) => {
  try {
    const { name } = req.body || {};
    if (!name) return res.status(400).json({ ok: false, error: 'missing name' });

    // × × ×§×” ××ª ×”×¡×™×•××ª
    const base = name.replace(/\.[^.]+$/, '');

    // ×ª××œ×•×œ ××“×•××”
    const transcript = [
      '××˜×•×¤×œ: ×× ×™ ××¨×’×™×© ×©×× ×™ ×›×œ ×”×–××Ÿ ×¦×¨×™×š ×œ×”×™×•×ª ××•×©×œ×.',
      '××˜×¤×œ: ×•××” ×§×•×¨×” ×›×©××ª×” ×œ× ××¨×’×™×© ××•×©×œ×?',
      '××˜×•×¤×œ: ××– ×× ×™ ××¨×’×™×© ×©× ×›×©×œ×ª×™ ×œ×’××¨×™...',
      '××˜×¤×œ: ×–×” × ×©××¢ ×›××• ×—×©×™×‘×” ×©×œ ×”×›×œ ××• ×›×œ×•×.'
    ];

    // × ×™×ª×•×— CBT ×‘×¡×™×¡×™
    const summary = {
      recording: name,
      createdAt: new Date().toISOString(),
      mood: '××ª×— ×‘×ª×—×™×œ×ª ×”×¤×’×™×©×”, ×¨×•×’×¢ ×œ×§×¨××ª ×”×¡×•×£',
      automaticThoughts: [
        '×× ×× ×™ ×œ× ××•×©×œ× â€“ ×× ×™ ×›×™×©×œ×•×Ÿ',
        '×× ×™ ×¦×¨×™×š ×œ×¨×¦×•×ª ××ª ×›×•×œ×'
      ],
      cognitiveDistortions: ['×”×›×œ ××• ×›×œ×•×', '×”×›×œ×œ×” ×™×ª×¨×”'],
      insights: ['×”×‘×™×Ÿ ×©×”×¦×•×¨×š ×‘×©×œ××•×ª ×¤×•×’×¢ ×‘×©×œ×•×•×” ×©×œ×•'],
      homework: ['×ª×¨×’×•×œ ×§×‘×œ×” ×¢×¦××™×ª ×›×œ ×¢×¨×‘', '×œ×¨×©×•× 3 ×“×‘×¨×™× ×˜×•×‘×™× ×¢×œ ×¢×¦××• ×‘×™×•×'],
      transcript
    };


    const jsPath = path.join(NOTES_DIR, `${base}.json`);
    const mdPath = path.join(NOTES_DIR, `${base}.md`);

    await fs.promises.writeFile(jsPath, JSON.stringify(summary, null, 2), 'utf8');

    // ×©××™×¨×” ×œ-Markdown
    const mdLines = [
      `**××¦×‘ ×¨×’×©×™:** ${summary.mood}`,
      `**××—×©×‘×•×ª ××•×˜×•××˜×™×•×ª:**`,
      ...summary.automaticThoughts.map(t => `- ${t}`),
      `**×¢×™×•×•×ª×™× ×§×•×’× ×™×˜×™×‘×™×™×:**`,
      ...summary.cognitiveDistortions.map(t => `- ${t}`),
      `**×ª×•×‘× ×•×ª:**`,
      ...summary.insights.map(t => `- ${t}`),
      `**××©×™××•×ª ×‘×™×ª:**`,
      ...summary.homework.map(t => `- ${t}`),
      '',
      '**×ª××œ×•×œ:**',
      ...summary.transcript.map(l => `> ${l}`)
    ];
    await fs.promises.writeFile(mdPath, mdLines.join('\n'), 'utf8');

    res.json({ ok: true, summary });
  } catch (e) {
    res.status(500).json({ ok: false, error: e.message });
  }
});

// ---------- PDF export from Markdown (RTL + Hebrew font) ----------

app.get('/api/notes/:base.pdf', async (req, res) => {
  console.log('ğŸ“„ PDF route base =', req.params.base);
  try {
    const base = req.params.base;
    const notesDir = path.join(RECORDINGS_DIR, 'notes');
    const mdPath = path.join(notesDir, `${base}.md`);
    if (!fs.existsSync(mdPath)) {
      return res.status(404).json({ ok: false, error: 'not found' });
    }

    // 1) Markdown -> HTML
    const md = fs.readFileSync(mdPath, 'utf8');
    const htmlBody = marked.parse(md);

    // 2) ×”×˜××¢×ª ×’×•×¤×Ÿ ×¢×‘×¨×™ (×× ××•×’×“×¨ ×‘-PDF_FONT)
    let fontFace = '';
    try {
      const fontPath = process.env.PDF_FONT;
      if (fontPath && fs.existsSync(fontPath)) {
        const fontData = fs.readFileSync(fontPath);
        const b64 = fontData.toString('base64');
        fontFace = `
          @font-face {
            font-family: "NotoHeb";
            src: url(data:font/ttf;base64,${b64}) format("truetype");
            font-weight: normal;
            font-style: normal;
            font-display: swap;
          }
          body { font-family: "NotoHeb", system-ui, sans-serif; }
        `;
      }
    } catch (_) {}

    // 3) HTML ×¢×•×˜×£ (RTL, ×™×™×©×•×¨ ×œ×™××™×Ÿ, ×‘×•×œ×˜×™×, ××¨×•×•×—×™×)
    const html = `
      <!doctype html>
      <html lang="he" dir="rtl">
      <head>
        <meta charset="utf-8" />
        <style>
          ${fontFace}
          html, body { margin: 0; padding: 0; }
          body { direction: rtl; font-size: 14px; line-height: 1.6; color: #111; padding: 28px; }
          h1, h2, h3, h4 { margin: 0 0 10px; }
          h1 { font-size: 22px; }
          h2 { font-size: 18px; }
          h3 { font-size: 16px; }
          p { margin: 0 0 8px; }
          ul { margin: 0 0 10px; padding-right: 20px; }
          li { margin: 0 0 4px; }
          blockquote {
            border-right: 3px solid #ddd; padding-right: 10px; margin: 8px 0; color: #333;
          }
          .title { font-size: 22px; font-weight: 700; margin-bottom: 12px; }
          .meta { color:#555; font-size: 12px; margin-bottom: 16px; }
        </style>
      </head>
      <body>
        <div class="title">×›×ª×‘ ××—×¨×™</div>
        <div class="meta">${base}</div>
        ${htmlBody}
      </body>
      </html>
    `;

    // 4) ×™×¦×™×¨×ª PDF ×¢× Puppeteer (Chromium)
    const browser = await puppeteer.launch({
      args: ['--no-sandbox', '--font-render-hinting=none']
    });
    const page = await browser.newPage();
    await page.setContent(html, { waitUntil: 'networkidle0' });

    const pdf = await page.pdf({
      format: 'A4',
      printBackground: true,
      margin: { top: '20mm', bottom: '20mm', left: '15mm', right: '15mm' }
    });

    await browser.close();

    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename="${base}.pdf"`);
    res.send(pdf);

  } catch (e) {
    console.error('PDF error:', e);
    res.status(500).json({ ok: false, error: e.message });
  }
});
// ---------- /PDF export ----------
