import fs from 'node:fs';
import http from 'node:http';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import { spawn } from 'node:child_process';
import WebSocket, { WebSocketServer } from 'ws';
import dotenv from 'dotenv';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
dotenv.config({ path: path.join(__dirname, '.env') });

const PORT = process.env.PORT || 8787;
const DG_KEY = process.env.DEEPGRAM_API_KEY;
if (!DG_KEY) {
  console.error('Missing DEEPGRAM_API_KEY in server/.env');
  process.exit(1);
}

const recordingsDir = path.join(__dirname, 'recordings');
fs.mkdirSync(recordingsDir, { recursive: true });

function newId() { return 'rec_' + Date.now().toString(36); }

function webmToPCM16(webmBuffer) {
  return new Promise((resolve, reject) => {
    const args = [
      '-hide_banner', '-loglevel', 'error',
      '-f', 'webm', '-i', 'pipe:0',
      '-ac', '1', '-ar', '16000', '-f', 's16le', 'pipe:1',
    ];
    const ff = spawn('ffmpeg', args, { stdio: ['pipe', 'pipe', 'pipe'] });
    const chunks = [];
    ff.stdout.on('data', d => chunks.push(Buffer.from(d)));
    ff.on('close', code => code === 0 ? resolve(Buffer.concat(chunks)) : reject(new Error('ffmpeg failed')));
    ff.stdin.end(webmBuffer);
  });
}

const server = http.createServer();
const wss = new WebSocketServer({ server, path: '/realtime' });

  

    try { webmStream.end(); } catch {}
    console.log('ðŸ”š session closed');
  });
  

    console.error('WS error:', err);
    try { webmStream.end(); } catch {}
  });
  
  console.log('ðŸŽ§ new session:', sessionId);

  // ×—×™×‘×•×¨ ×œ-Deepgram Realtime (× ×–×™×Ÿ ×œ×• PCM16 16kHz)
  const dgUrl = 'wss://api.deepgram.com/v1/listen?encoding=linear16&sample_rate=16000&channels=1&smart_format=true&interim_results=true&language=he';
  const dg = new WebSocket(dgUrl, { headers: { Authorization: `Token ${DG_KEY}` } });

  dg.on('open', () => ws.send(JSON.stringify({ type: 'info', message: `connected: ${sessionId}` })));

  // ××™×¨×•×¢×™ ×ª×ž×œ×•×œ × ×›× ×¡×™× ×ž-Deepgram â€“ ×©×•×ž×¨×™× final ×œ×§×•×‘×¥ ×˜×§×¡×˜
  dg.on('message', (data) => {
    try {
      const msg = JSON.parse(data.toString());
      const text = msg?.channel?.alternatives?.[0]?.transcript || '';
      if (!text) return;
      const isFinal = Boolean(msg?.is_final);
      ws.send(JSON.stringify({ type: isFinal ? 'final' : 'partial', text }));
      if (isFinal) fs.appendFileSync(txtPath, text + '\n');
    } catch (e) {
      ws.send(JSON.stringify({ type: 'error', message: String(e) }));
    }
  });

  dg.on('error', (e) => ws.send(JSON.stringify({ type: 'error', message: 'Deepgram: ' + e.message })));
  dg.on('close', () => ws.send(JSON.stringify({ type: 'info', message: 'Deepgram closed' })));


    // ×‘×™× ××¨×™ = ××•×“×™×• webm/opus ×ž×”×“×¤×“×¤×Ÿ; ×˜×§×¡×˜ = ×¤×§×•×“×•×ª
    if (typeof data === 'string') {
      try {
        const msg = JSON.parse(data);
        if (msg.type === 'stop') { try { dg.close(); } catch {} ws.close(); }
      } catch {}
      return;
    }
    // ×©×ž×™×¨×ª ×”××•×“×™×• ×”×’×•×œ×ž×™ ×œ×§×•×‘×¥ .webm
    const buf = Buffer.from(data);
    webmStream.write(buf);

    // ×”×ž×¨×” ×œ-PCM16 ×•×©×œ×™×—×” ×œ-Deepgram
    try {
      const pcm = await webmToPCM16(buf);
      if (dg.readyState === dg.OPEN) dg.send(pcm);
    } catch (e) {
      ws.send(JSON.stringify({ type: 'error', message: 'Transcode error: ' + e.message }));
    }
  });


    try { webmStream.end(); } catch {}
    try { dg.close(); } catch {}
    console.log('ðŸ”š session closed:', sessionId, 'files:', path.basename(webmPath), path.basename(txtPath));
  });

server.listen(PORT, () => console.log(`WS server on :${PORT}`));

wss.on('connection',(ws)=>{
  const id='rec_'+Math.random().toString(36).slice(2,10);
  const wav=path.join(recordingsDir,`${id}.wav`);
  const out=fs.createWriteStream(wav);
  writeWavHeader(out);
  let bytes=0;
  console.log('ðŸŽ§ new session',id);

  ws.on('message',(m)=>{
    const b=Buffer.isBuffer(m)?m:Buffer.from(m);
    out.write(b);
    bytes+=b.length;
  });


    out.end(()=>{
      try{
        const fd=fs.openSync(wav,'r+');
        const p=Buffer.alloc(4);
        p.writeUInt32LE(36+bytes,0); fs.writeSync(fd,p,0,4,4);   // RIFF size
        p.writeUInt32LE(bytes,0);    fs.writeSync(fd,p,0,4,40);  // data size
        fs.closeSync(fd);
        console.log('ðŸ”š saved',wav,bytes,'bytes');
      }catch(e){ console.error('WAV header patch error:',e); }
    });
  });


    console.error('WS error:',e);
    try{ out.end(); }catch{}
  });
});
