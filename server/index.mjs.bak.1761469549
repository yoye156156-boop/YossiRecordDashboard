import fs from 'node:fs';
import http from 'node:http';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import { spawn } from 'node:child_process';
import WebSocket, { WebSocketServer } from 'ws';
import dotenv from 'dotenv';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
dotenv.config({ path: path.join(__dirname, '.env') });

const PORT = process.env.PORT || 8787;
const DG_KEY = process.env.DEEPGRAM_API_KEY;
if (!DG_KEY) {
  console.error('Missing DEEPGRAM_API_KEY in server/.env');
  process.exit(1);
}

const recordingsDir = path.join(__dirname, 'recordings');
fs.mkdirSync(recordingsDir, { recursive: true });

function newId() { return 'rec_' + Date.now().toString(36); }

function webmToPCM16(webmBuffer) {
  return new Promise((resolve, reject) => {
    const args = [
      '-hide_banner', '-loglevel', 'error',
      '-f', 'webm', '-i', 'pipe:0',
      '-ac', '1', '-ar', '16000', '-f', 's16le', 'pipe:1',
    ];
    const ff = spawn('ffmpeg', args, { stdio: ['pipe', 'pipe', 'pipe'] });
    const chunks = [];
    ff.stdout.on('data', d => chunks.push(Buffer.from(d)));
    ff.on('close', code => code === 0 ? resolve(Buffer.concat(chunks)) : reject(new Error('ffmpeg failed')));
    ff.stdin.end(webmBuffer);
  });
}

const server = http.createServer();
const wss = new WebSocketServer({ server, path: '/realtime' });

wss.on('connection', async (ws) => {
  const sessionId = newId();
  const webmPath = path.join(recordingsDir, `${sessionId}.webm`);
  const txtPath  = path.join(recordingsDir, `${sessionId}.txt`);
  const webmStream = fs.createWriteStream(webmPath);
  ws.on('message', (msg, isBinary) => {
    try {
      if (isBinary || Buffer.isBuffer(msg)) {
        webmStream.write(msg);
      } else {
        // ××•×¤×¦×™×•× ×œ×™: ×× ×™×© ×œ×š txtPath ×•××ª×” ×ž×§×‘×œ ×˜×§×¡×˜ (JSON), ××¤×©×¨ ×œ×©×ž×•×¨ ×’× ×˜×§×¡×˜:
        // fs.appendFileSync(txtPath, msg.toString() + '\n');
      }
    } catch (e) {
      console.error('write error:', e);
    }
  });
  
  ws.on('close', () => {
    try { webmStream.end(); } catch {}
    console.log('ðŸ”š session closed');
  });
  
  ws.on('error', (err) => {
    console.error('WS error:', err);
    try { webmStream.end(); } catch {}
  });
  
  console.log('ðŸŽ§ new session:', sessionId);

  // ×—×™×‘×•×¨ ×œ-Deepgram Realtime (× ×–×™×Ÿ ×œ×• PCM16 16kHz)
  const dgUrl = 'wss://api.deepgram.com/v1/listen?encoding=linear16&sample_rate=16000&channels=1&smart_format=true&interim_results=true&language=he';
  const dg = new WebSocket(dgUrl, { headers: { Authorization: `Token ${DG_KEY}` } });

  dg.on('open', () => ws.send(JSON.stringify({ type: 'info', message: `connected: ${sessionId}` })));

  // ××™×¨×•×¢×™ ×ª×ž×œ×•×œ × ×›× ×¡×™× ×ž-Deepgram â€“ ×©×•×ž×¨×™× final ×œ×§×•×‘×¥ ×˜×§×¡×˜
  dg.on('message', (data) => {
    try {
      const msg = JSON.parse(data.toString());
      const text = msg?.channel?.alternatives?.[0]?.transcript || '';
      if (!text) return;
      const isFinal = Boolean(msg?.is_final);
      ws.send(JSON.stringify({ type: isFinal ? 'final' : 'partial', text }));
      if (isFinal) fs.appendFileSync(txtPath, text + '\n');
    } catch (e) {
      ws.send(JSON.stringify({ type: 'error', message: String(e) }));
    }
  });

  dg.on('error', (e) => ws.send(JSON.stringify({ type: 'error', message: 'Deepgram: ' + e.message })));
  dg.on('close', () => ws.send(JSON.stringify({ type: 'info', message: 'Deepgram closed' })));

  ws.on('message', async (data) => {
    // ×‘×™× ××¨×™ = ××•×“×™×• webm/opus ×ž×”×“×¤×“×¤×Ÿ; ×˜×§×¡×˜ = ×¤×§×•×“×•×ª
    if (typeof data === 'string') {
      try {
        const msg = JSON.parse(data);
        if (msg.type === 'stop') { try { dg.close(); } catch {} ws.close(); }
      } catch {}
      return;
    }
    // ×©×ž×™×¨×ª ×”××•×“×™×• ×”×’×•×œ×ž×™ ×œ×§×•×‘×¥ .webm
    const buf = Buffer.from(data);
    webmStream.write(buf);

    // ×”×ž×¨×” ×œ-PCM16 ×•×©×œ×™×—×” ×œ-Deepgram
    try {
      const pcm = await webmToPCM16(buf);
      if (dg.readyState === dg.OPEN) dg.send(pcm);
    } catch (e) {
      ws.send(JSON.stringify({ type: 'error', message: 'Transcode error: ' + e.message }));
    }
  });

  ws.on('close', () => {
    try { webmStream.end(); } catch {}
    try { dg.close(); } catch {}
    console.log('ðŸ”š session closed:', sessionId, 'files:', path.basename(webmPath), path.basename(txtPath));
  });
});

server.listen(PORT, () => console.log(`WS server on :${PORT}`));
